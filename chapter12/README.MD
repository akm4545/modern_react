웹사이트 성능과 사용자 경험 사이의 상관관계
2019년 미국 시애틀에 있는 디지털 마케팅 에이전시 회사인 Protent의 조사

- 웹사이트의 성능이 끼치는 영향
1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 전자상거래 전환율(실제 구매로 이어지는 고객의 비율)이 2.5배 더 높다

0 ~ 5초 범위에서 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다 즉 5초 이상 느려지면 전환율은 20% 가까이 떨어진다

페이지 로드 시간이 0 ~ 2초 사이인 페이지에서 가장 높은 전환율을 달성할 수 있다

소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는 데 영향을 미친다고 밝혔다

절반 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요 없다고 밝혔다

- 구글에서 내놓은 사이트 성능에 관한 통계
전체 웹피이지를 표시하는 데 필요한 최적의 평균 리소스 요청 수는 50회 미만이다(한 페이지를 로딩하는 데 50회 미만의 요청이 발생해야 한다)

평균적으로 웹 페이지 전체를 요청하는 데 15.3초가 걸린다

인간의 뇌와 신경계를 분석한 결과 페이지 로드 시간이 1초에서 10초로 늘어날수록 모바일 사이트를 이탈할 확률이 123% 증가한다

또한 구글은 요즘의 웹사이트의 성능에 대해 다음과 같은 글을 남겼다

전 세계의 사용자의 대부분이 모바일을 3G가 아닌 4G로 사용하고 있음에도 불구하고 대부분의 모바일 사이트는 여전히 느리고 너무 많은 요소 때문에 비대해졌다


개발자들이 성능에 크게 관심을 기울이지 않는 것 또한 사실이다

이유로는

1. 개발자의 기기는 대부분 일반적인 사용자의 평균적인 기기보다 성능이 뛰어나기 때문에 이러한 문제를 대체로 느끼지 못한다
또한 네트워크 환경도 안정적이다 따라서 웬만큼 잘못되지 않은 이상 개발자의 기기에서 성능 문제를 경험하기란 어렵다

2. 성능 개선 작업은 새로운 기능을 개발하는것보다 쉽지도, 재밌지도 않고 서비스를 개발하는 작업 대비 눈에 띄는 성능 향상을 기대하기도 어렵다는 점이다
실무 개발자들은 항상 많은 양의 업무 요청을 처리하고 버그와 씨름하고 있기 때문에 대부분의 서비스 출시를 최우선 과제로 삼는다



핵심 웹 지표
외국에서는 Core Web Vital로 알려져 있다 핵심 웹 지표는 구글에서 만든 지표로 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일겉는 용어

구글에서 핵심 웹 지표로 꼽는 지표는 다음과 같다

최대 콘텐츠풀 페인드(LCP: Largest Contentful Paint)
최초 입력 지연(FID: First Input Delay)
누적 레이아웃 이동(CSL: Cumilative Layout Shift)

핵심 지표까지는 아니지만 특정 문제를 진단하는데 사용될 수도 있는 요소
최초 바이트까지의 시간(TTFB: Time To First Byte)
최초 콘텐츠풀 시간(FCP: First Contentful Paint)


최대 콘텐츠풀 페인트(LCP)
페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간
뷰포트는 사용자에게 현재 노출되는 화면을 의미 사용자에게 노출되는 영역은 기기에 의존하므로 뷰포트 크기는 기기마다 다르다

뷰포트 내부에서 큰 이미지와 텍스트는 다음과 같이 정의
<img>
<svg>내부의 <image>
poster 속성을 사용하는 <video>
url()을 통해 불러온 배경 이미지가 있는 요소
텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
이 블록 레벨 요소에는 <p>, <div>등이 포함

요약하자면 각 엘리먼트가 등장한 시점부터 텍스트 또는 이미지가 완전히 로딩되는 시점

실제 크기가 크더라도 뷰포트 영역 밖에 넘치는 요소가 있다면 해당 영역의 크기는 고려되지 않는다
따라서 아무리 콘텐츠 높이가 길어도 최대 콘텐츠풀 페인트에 영향을 미치는 부분은 오직 뷰포트 영역뿐이다

사용자가 페이지가 어느 정도 로딩됐다고 인지하는 시점
ex) document가 1000~2000줄에 달하는 웹사이트의 경우 하단 영역은 IntersectionObserver로 구현돼 있어 아직 뷰포트에 걸치지 않아 미처 로딩돼 있지
않다고 하더라도 일단 사용자에게 노출되는 부분만 로딩돼 있다면 사용자는 페이지 로딩이 완료됐다고 느낄것이다
즉 뷰포트 영역을 기준으로 판단할 것이다

최대 콘텐츠풀 페인트에서 좋은 점수란 해당 지표가 2.5초 내로 응답이 오는 것이다 4초 이내로 응답이 온다면 보통, 그 이상이 걸리면 나쁨으로 판단

개선 방안
텍스트는 언제나 옳다
최대 콘텐츠풀 페인트 예상 영역에 이미지가 아닌 문자열을 넣는 것

이미지는 어떻게 불러올 것인가?
개발자가 선택할 수 있는 이미지 노출 방법
1. img
<img src="lcp.jpg" ... />
2. svg
<svg xmlns="http://www.w3.org/1000/svg">
    <image href="lcp.jpg>
</svg>
3. 비디오의 경우
<video poster="lcp.jpg"></video>
4. background-img: url()
<div style="background-image: url(lcp.jpg)">...</div>

1번과 3번의 예제가 빠르게 완성된다
<img>: 이미지는 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 빠르게 요청이 일어난다 프리로드 스캐너란 HTML을 파싱하는 단계를 차단하지 않고 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 찾아 로딩하는 브라우저의 기능이다 <img> 내부의 리소스는 이처럼 HTML 파싱이 미처 완료되지 않더라도 프리로드 스태너가 병렬적으로 리소스를 다운로드하므로 최대 콘턴츠풀 페인트 요소를 불러오기에 적절한 방법이다 이는 <picture>도 마찬가지다

<svg>: <svg> 내부의 <img>가 로딩이 완료되기 전까지는 최대 콘텐츠풀 페인트가 완료되지 않는다 <svg>는 모든 리소스를 다 불러온 이후에 이미지를 불러온다

<video>의 poster: poster는 사용자가 video요소를 재생하거나 탐색하기 전까지 노출되는 요소 이 역시 마찬가지로 프리로드 스캐너에 의해 조기 발견되어 
<img>와 같은 성능을 나타낸다 poster가 없는 video의 경우 video를 실제로 로딩해 첫 번째 프레임을 해당 poster 리소스로 대체할 예정이다 그러므로 video가 최대 콘텐츠풀 페인트에 영향을 받을 것 같다면 poster를 반드시 넣어주는 것이 좋다

background-image: url(): background-image를 비롯해서 CSS에 있는 리소스는 항상 느리다 이러한 리소스는 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문 

그 밖에 주의점
이미지 무손실 압축: 웹 서비스 이미지는 가능한 한 무손실 형식으로 압축해 최소한의 용량으로 서비스하는 것이 좋다

loading=lazy 주의: loading=lazy는 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략으로 <img>, <iframe>등에 적용할 수 있지만 문제는 최대 콘텐츠풀 콘텐츠의 이미지는 중요하지 않은 리소스로 분류해서는 안된다 이는 그저 로딩 속도만 늦출 뿐 지표 점수에는 도움이 되지 않는다

fadein과 같은 각종 애니메이션: 당연하게도 이미지가 그냥 뜨는 것보다 fadeIn ease 10s와 같이 처리한다면 최대 콘텐츠풀 페인트도 그만큼 늦어진다

클라이언트에서 빌드하지 말 것: 서버에서 빌드해온 HTML을 프리로드 스캐너가 바로 읽어서 최대 콘텐츠풀 페인트로 빠르게 가져간다
만약 최대 콘텐츠풀 페인트에 대해 다음과 같은 useEffect 코드가 있다면
useEffect(() => {
    ;(async function loadData() {
        const result = await fetch('https://example.com/data)

        if(result.ok){
            setShow(true) //최대 콘텐츠풀 페인트 영역 노출
        }
    })()
}, [])
이 코드는 HTML을 다운로드한 직후가 아닌 리액트 코드를 파싱하고 읽어서 API 요청을 보내고 응답을 받는 만큼 늦어진다 따라서 가능한 한 이 영역은 서버에서 미리 빌드된 채로 오는 것이 좋다

최대 콘텐츠풀 리소스는 직접 호스팅: 가능하다면 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋다 일반적인 경우 Cloudinary같은 이미지 최적화 서비스를 사용해 하나의 이미지에 대해 크기도 줄이고 포맷도 변환하고 압축해서 이미지를 관리하지만 다른 출처(origin)에서 이렇게 정제한
이미지를 가져오는 것은 최적화에 별로 좋은 영향을 미치지 않는다 왜냐하면 이미 연결이 맺어진 현재 출처와는 다르게 완선히 새로운 출처의 경우에는 네트워크 커넥션부터 다시 수행해야 하기 때문이다
때문에 중요한 리소스는 직접 다루고 그 외에 덜 중요한 리소스에 대해서만 이미지 최적화 서비스를 사용하는 식으로 관리하는 것이 좋다


최초 입력 지연(FID)
페이지가 아무리 빨리 로딩되도 사용자가 클릭을 비롯한 웹사이트와 상호작용을 할 수 없다면 사용자는 웹사이트가 느리다고 생각할 것이다
웹페이지의 로딩 속도만큼 중요한 것이 웹사이트의 반응 속도다 웨사이트의 반응 속도를 측정하는 지표가 최초 입력 지연(FID: First Input Delay)이다

최초 입력 지연의 정의
사용자가 페이지와 처음 상호 작용할 때(예: 링크를 클릭ㅎ거나 버튼을 탭하거나 사용자 지정 JavaScript 기반 컨트롤을 사용할 때)부터 해당 상호 작용에 대한 응답으로 부라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간

웹사이트 내부의 이벤트가 반응이 늦어지는 이유
해당 입력을 처리해야 하는 브라우저의 메인 스레드가 바쁘기 때문 
대규모 렌더링이 일어나고 있거나 대규모 자바스크립트 파일을 분석하고 실행하는 등 다른 작업을 처리하는데 리소스를 할애하기 떄문
자바스크립트 실행 환경은 싱글 스레드이기 때문에 자바스크립트가 이벤트 리스너와 같은 다른 작업을 실행할 수 없어 지연이 발생
이벤트가 발생하는 시점에 최대한 메인 스레드가 다른 작업을 처리할 수 있도록 여유를 만들어 둬야 사용자에게 빠른 반응성을 보장할 수 있다

사용자의 입력은 타이핑, 터치(클릭), 핀치 투 줌, 스크롤 등 다양하다
반응성에 해당하는 사용자의 개별 입력 작업에 초점을 맞추고 측정
스크롤이나 핀치 투 줌 등은 사용자의 입력이 아닌 애니메이션으로 분류해 측정 대상에서 제외

구글은 사용자 경험을 크게 4가지로 분류해 정의하는 이를 RAIL이라고 한다
Response: 사용자의 입력에 대한 반응 속도 50ms 미만으로 이벤트를 처리할것
Animation: 애니메이션의 각 프레임을 10ms 이하로 생성할 것
Idel: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
Load: 5초 이내에 콘텐츠를 전달하고 인터랙션을 준비할 것

최초 입력 지연은 R에 해당하는 응답에 초점을 맞추고 있다

즉 최초 입력 지연이란 화면에 최초에 그려지고 난 뒤 사용자가 웹페이지에서 클릭 등 상호작용을 수행했을 때 메인 스레드가 이 이벤트에 대한 반응을 할 수 있을 때까지 걸리는 시간을 의미

기준 점수
최초 입력 지연의 좋은 점수를 얻기 위해서는 100ms 이내로 응답이 와야 하며 300ms 이내인 경우 보통, 그 이후의 경우에는 나쁨으로 처리

개선 방안
실행에 오래 걸리는 긴 작업을 분리
만약 실행에 오래 걸리는 작업이 있다면 몇 가지 대안을 연구해야 한다

꼭 웹페이지에서 해야 하는 작업인가: 만약 개발자의 최신 개발 기기에서도 오랜 시간이 소요되는 작업이라면 실제 사용자가 이용하는 경우에는 더욱 오래 걸릴 것이다 일반적인 사용자들의 기기는 그다지 성능이 좋지 못하고 또 기기의 환경이 쾌적하지도 않다 
꼭 웹페이지에서 처리해야 하는 작업이 아니라면 서버로 옮겨서 처리하는 것이 좋다

긴 작업을 여러 개로 분리하기: 단순히 실행이 오래 걸릴 것 같은 작업을 분리하는 것뿐만 아니라 웹페이지 최초 로딩에 필요하지 않은 내용을 나중에 불러오는것도 포함된다 예를 들어 웹페이지에서 팝업이나 레이어의 경우 사용자의 액션으로 인해 노출되는 이러한 요소들은 당장의 로딩에 필요하지 않은 리소시다 이러한 리소스는 리액트의 Suspense와 lazy를 혹은 Next.js의 dynamic을 이용해 나중에 불러오게 할 수 있다

자바스크립트 코드 최소화
번들링 도구를 이용하여 필요없는 코드를 제거한다고 해도 여전히 웹페이지를 불러오는 데 사용되지 않은 필요 없는 코드가 존재할 수 있다
이러한 코드를 크롬 개발자 도구를 통해 확인할 수 있다
확인하고 싶은 사이트를 방문한 다음 크롬 개발자 도구로 들어가 커버리지를 클릭한다
그 다음 기록 버튼을 클릭하고 웹페이지를 새로고침하자

표시된 모든 코드들이 필요 없는 코드이므로 삭제해야 한다는 것은 아니다 이 중에는 사용자의 특정 이벤트에 따라 실행되는 코드, 예기치 못한 상황에서 실행될 코드 등 다양한 것들이 존재할 수 있다
이러한 코드들은 당장에 급하지 않은 코드로 간주해 지연 로딩 기법, 사용자가 불러오거나 우선순위를 낮춰서 불러오는 것이 좋다

또한 폴리필의 크기가 제법 크므로 실제 코드에서 사용하는 기준이 아닌 인터넷 익스플로러 11에 없는 코드를 기준으로 하게 되면 폴리필의 크기가 기하급수적으로 커진다

폴리필을 넣기 전에 두 가지를 고려해야 한다
1. 폴리필이 필요한 환경인가
2. 꼭 필요한 폴리필인가
만약 사용하는 곳이 몇 군데 되지 않는다면 폴리필보다 직접 저수준 자바스크립트 코드를 작성해 구현하는 편이 코드 크기를 줄이는 데 도움이 될 수 있다


타사 자바스크립트 코드 실행의 지연
제 3자가 만든 타사 자바스크립트를 넣은 경우 이로 인해 메인 스레드가 잠시 점유되고 사용자에게 안 좋은 반응성을 제공한다면 주객이 전도되는 상황에 마딱뜨릴것이다

이러한 타사 스크립트는 대부분 웹페이지 로드에 중요한 자원이 아니므로 <script>의 async와 defer를 이용해 지연 불러오기를 하는 것이 좋다 

defer: script에 defer 속성이 있다면 먼저 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드 다운로드 중에도 HTML 파싱 등의 메인 스레드 작업은 멈추지 않는다 다운로드가 완료됐다 하더라도 이 스크립트의 실행은 페이지가 완전히 로딩된 이후에 맨 마지막에 실행

async: script에 async 속성이 있다면 마찬가지로 병렬로 다운로드 async 리소스의 다운로드가 완료되어 버리면 다른 리소스의 다운로드를 기다리지 않고 바로 실행 

둘 다 없는 경우: script를 만나는 순간 다운로드가 우선되며 다운로드가 완료되면 코드 실행이 우선된다 다른 작업은 다운로드와 실행이 끝날 때까지 미뤄진다

만약 광고와 같이 실제 사용자의 뷰포트 위치에 따라 불러와야 하는 컴포넌트라면 Intersection Observer를 이용해 뷰표트에 들어오는 시점에 불러오는 것이 좋다 광고는 물론 개발자와 웹페이지 제공자에게 중요한 리소스이지만 어디까지나 사용자가 좋은 웹사이트 경험을 얻고 페이지에 머물러야만 유의미한 리소스라고 봐야 한다 따라서 사용자가 기대하지 않은 추가적인 리소스는 실행을 조금 뒤로 미뤄두고 실행하는 시점을 최적화하는 것이 좋다
