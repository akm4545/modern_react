웹사이트 성능과 사용자 경험 사이의 상관관계
2019년 미국 시애틀에 있는 디지털 마케팅 에이전시 회사인 Protent의 조사

- 웹사이트의 성능이 끼치는 영향
1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 전자상거래 전환율(실제 구매로 이어지는 고객의 비율)이 2.5배 더 높다

0 ~ 5초 범위에서 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다 즉 5초 이상 느려지면 전환율은 20% 가까이 떨어진다

페이지 로드 시간이 0 ~ 2초 사이인 페이지에서 가장 높은 전환율을 달성할 수 있다

소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는 데 영향을 미친다고 밝혔다

절반 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요 없다고 밝혔다

- 구글에서 내놓은 사이트 성능에 관한 통계
전체 웹피이지를 표시하는 데 필요한 최적의 평균 리소스 요청 수는 50회 미만이다(한 페이지를 로딩하는 데 50회 미만의 요청이 발생해야 한다)

평균적으로 웹 페이지 전체를 요청하는 데 15.3초가 걸린다

인간의 뇌와 신경계를 분석한 결과 페이지 로드 시간이 1초에서 10초로 늘어날수록 모바일 사이트를 이탈할 확률이 123% 증가한다

또한 구글은 요즘의 웹사이트의 성능에 대해 다음과 같은 글을 남겼다

전 세계의 사용자의 대부분이 모바일을 3G가 아닌 4G로 사용하고 있음에도 불구하고 대부분의 모바일 사이트는 여전히 느리고 너무 많은 요소 때문에 비대해졌다


개발자들이 성능에 크게 관심을 기울이지 않는 것 또한 사실이다

이유로는

1. 개발자의 기기는 대부분 일반적인 사용자의 평균적인 기기보다 성능이 뛰어나기 때문에 이러한 문제를 대체로 느끼지 못한다
또한 네트워크 환경도 안정적이다 따라서 웬만큼 잘못되지 않은 이상 개발자의 기기에서 성능 문제를 경험하기란 어렵다

2. 성능 개선 작업은 새로운 기능을 개발하는것보다 쉽지도, 재밌지도 않고 서비스를 개발하는 작업 대비 눈에 띄는 성능 향상을 기대하기도 어렵다는 점이다
실무 개발자들은 항상 많은 양의 업무 요청을 처리하고 버그와 씨름하고 있기 때문에 대부분의 서비스 출시를 최우선 과제로 삼는다



핵심 웹 지표
외국에서는 Core Web Vital로 알려져 있다 핵심 웹 지표는 구글에서 만든 지표로 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일겉는 용어

구글에서 핵심 웹 지표로 꼽는 지표는 다음과 같다

최대 콘텐츠풀 페인드(LCP: Largest Contentful Paint)
최초 입력 지연(FID: First Input Delay)
누적 레이아웃 이동(CSL: Cumilative Layout Shift)

핵심 지표까지는 아니지만 특정 문제를 진단하는데 사용될 수도 있는 요소
최초 바이트까지의 시간(TTFB: Time To First Byte)
최초 콘텐츠풀 시간(FCP: First Contentful Paint)


최대 콘텐츠풀 페인트(LCP)
페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간
뷰포트는 사용자에게 현재 노출되는 화면을 의미 사용자에게 노출되는 영역은 기기에 의존하므로 뷰포트 크기는 기기마다 다르다

뷰포트 내부에서 큰 이미지와 텍스트는 다음과 같이 정의
<img>
<svg>내부의 <image>
poster 속성을 사용하는 <video>
url()을 통해 불러온 배경 이미지가 있는 요소
텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
이 블록 레벨 요소에는 <p>, <div>등이 포함

요약하자면 각 엘리먼트가 등장한 시점부터 텍스트 또는 이미지가 완전히 로딩되는 시점

실제 크기가 크더라도 뷰포트 영역 밖에 넘치는 요소가 있다면 해당 영역의 크기는 고려되지 않는다
따라서 아무리 콘텐츠 높이가 길어도 최대 콘텐츠풀 페인트에 영향을 미치는 부분은 오직 뷰포트 영역뿐이다

사용자가 페이지가 어느 정도 로딩됐다고 인지하는 시점
ex) document가 1000~2000줄에 달하는 웹사이트의 경우 하단 영역은 IntersectionObserver로 구현돼 있어 아직 뷰포트에 걸치지 않아 미처 로딩돼 있지
않다고 하더라도 일단 사용자에게 노출되는 부분만 로딩돼 있다면 사용자는 페이지 로딩이 완료됐다고 느낄것이다
즉 뷰포트 영역을 기준으로 판단할 것이다

최대 콘텐츠풀 페인트에서 좋은 점수란 해당 지표가 2.5초 내로 응답이 오는 것이다 4초 이내로 응답이 온다면 보통, 그 이상이 걸리면 나쁨으로 판단

개선 방안
텍스트는 언제나 옳다
최대 콘텐츠풀 페인트 예상 영역에 이미지가 아닌 문자열을 넣는 것

이미지는 어떻게 불러올 것인가?
개발자가 선택할 수 있는 이미지 노출 방법
1. img
<img src="lcp.jpg" ... />
2. svg
<svg xmlns="http://www.w3.org/1000/svg">
    <image href="lcp.jpg>
</svg>
3. 비디오의 경우
<video poster="lcp.jpg"></video>
4. background-img: url()
<div style="background-image: url(lcp.jpg)">...</div>

1번과 3번의 예제가 빠르게 완성된다
<img>: 이미지는 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 빠르게 요청이 일어난다 프리로드 스캐너란 HTML을 파싱하는 단계를 차단하지 않고 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 찾아 로딩하는 브라우저의 기능이다 <img> 내부의 리소스는 이처럼 HTML 파싱이 미처 완료되지 않더라도 프리로드 스태너가 병렬적으로 리소스를 다운로드하므로 최대 콘턴츠풀 페인트 요소를 불러오기에 적절한 방법이다 이는 <picture>도 마찬가지다

<svg>: <svg> 내부의 <img>가 로딩이 완료되기 전까지는 최대 콘텐츠풀 페인트가 완료되지 않는다 <svg>는 모든 리소스를 다 불러온 이후에 이미지를 불러온다

<video>의 poster: poster는 사용자가 video요소를 재생하거나 탐색하기 전까지 노출되는 요소 이 역시 마찬가지로 프리로드 스캐너에 의해 조기 발견되어 
<img>와 같은 성능을 나타낸다 poster가 없는 video의 경우 video를 실제로 로딩해 첫 번째 프레임을 해당 poster 리소스로 대체할 예정이다 그러므로 video가 최대 콘텐츠풀 페인트에 영향을 받을 것 같다면 poster를 반드시 넣어주는 것이 좋다

background-image: url(): background-image를 비롯해서 CSS에 있는 리소스는 항상 느리다 이러한 리소스는 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문 

그 밖에 주의점
이미지 무손실 압축: 웹 서비스 이미지는 가능한 한 무손실 형식으로 압축해 최소한의 용량으로 서비스하는 것이 좋다

loading=lazy 주의: loading=lazy는 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략으로 <img>, <iframe>등에 적용할 수 있지만 문제는 최대 콘텐츠풀 콘텐츠의 이미지는 중요하지 않은 리소스로 분류해서는 안된다 이는 그저 로딩 속도만 늦출 뿐 지표 점수에는 도움이 되지 않는다

fadein과 같은 각종 애니메이션: 당연하게도 이미지가 그냥 뜨는 것보다 fadeIn ease 10s와 같이 처리한다면 최대 콘텐츠풀 페인트도 그만큼 늦어진다

클라이언트에서 빌드하지 말 것: 서버에서 빌드해온 HTML을 프리로드 스캐너가 바로 읽어서 최대 콘텐츠풀 페인트로 빠르게 가져간다
만약 최대 콘텐츠풀 페인트에 대해 다음과 같은 useEffect 코드가 있다면
useEffect(() => {
    ;(async function loadData() {
        const result = await fetch('https://example.com/data)

        if(result.ok){
            setShow(true) //최대 콘텐츠풀 페인트 영역 노출
        }
    })()
}, [])
이 코드는 HTML을 다운로드한 직후가 아닌 리액트 코드를 파싱하고 읽어서 API 요청을 보내고 응답을 받는 만큼 늦어진다 따라서 가능한 한 이 영역은 서버에서 미리 빌드된 채로 오는 것이 좋다

최대 콘텐츠풀 리소스는 직접 호스팅: 가능하다면 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋다 일반적인 경우 Cloudinary같은 이미지 최적화 서비스를 사용해 하나의 이미지에 대해 크기도 줄이고 포맷도 변환하고 압축해서 이미지를 관리하지만 다른 출처(origin)에서 이렇게 정제한
이미지를 가져오는 것은 최적화에 별로 좋은 영향을 미치지 않는다 왜냐하면 이미 연결이 맺어진 현재 출처와는 다르게 완선히 새로운 출처의 경우에는 네트워크 커넥션부터 다시 수행해야 하기 때문이다
때문에 중요한 리소스는 직접 다루고 그 외에 덜 중요한 리소스에 대해서만 이미지 최적화 서비스를 사용하는 식으로 관리하는 것이 좋다


최초 입력 지연(FID)
페이지가 아무리 빨리 로딩되도 사용자가 클릭을 비롯한 웹사이트와 상호작용을 할 수 없다면 사용자는 웹사이트가 느리다고 생각할 것이다
웹페이지의 로딩 속도만큼 중요한 것이 웹사이트의 반응 속도다 웨사이트의 반응 속도를 측정하는 지표가 최초 입력 지연(FID: First Input Delay)이다

최초 입력 지연의 정의
사용자가 페이지와 처음 상호 작용할 때(예: 링크를 클릭ㅎ거나 버튼을 탭하거나 사용자 지정 JavaScript 기반 컨트롤을 사용할 때)부터 해당 상호 작용에 대한 응답으로 부라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간

웹사이트 내부의 이벤트가 반응이 늦어지는 이유
해당 입력을 처리해야 하는 브라우저의 메인 스레드가 바쁘기 때문 
대규모 렌더링이 일어나고 있거나 대규모 자바스크립트 파일을 분석하고 실행하는 등 다른 작업을 처리하는데 리소스를 할애하기 떄문
자바스크립트 실행 환경은 싱글 스레드이기 때문에 자바스크립트가 이벤트 리스너와 같은 다른 작업을 실행할 수 없어 지연이 발생
이벤트가 발생하는 시점에 최대한 메인 스레드가 다른 작업을 처리할 수 있도록 여유를 만들어 둬야 사용자에게 빠른 반응성을 보장할 수 있다

사용자의 입력은 타이핑, 터치(클릭), 핀치 투 줌, 스크롤 등 다양하다
반응성에 해당하는 사용자의 개별 입력 작업에 초점을 맞추고 측정
스크롤이나 핀치 투 줌 등은 사용자의 입력이 아닌 애니메이션으로 분류해 측정 대상에서 제외

구글은 사용자 경험을 크게 4가지로 분류해 정의하는 이를 RAIL이라고 한다
Response: 사용자의 입력에 대한 반응 속도 50ms 미만으로 이벤트를 처리할것
Animation: 애니메이션의 각 프레임을 10ms 이하로 생성할 것
Idel: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
Load: 5초 이내에 콘텐츠를 전달하고 인터랙션을 준비할 것

최초 입력 지연은 R에 해당하는 응답에 초점을 맞추고 있다

즉 최초 입력 지연이란 화면에 최초에 그려지고 난 뒤 사용자가 웹페이지에서 클릭 등 상호작용을 수행했을 때 메인 스레드가 이 이벤트에 대한 반응을 할 수 있을 때까지 걸리는 시간을 의미

기준 점수
최초 입력 지연의 좋은 점수를 얻기 위해서는 100ms 이내로 응답이 와야 하며 300ms 이내인 경우 보통, 그 이후의 경우에는 나쁨으로 처리

개선 방안
실행에 오래 걸리는 긴 작업을 분리
만약 실행에 오래 걸리는 작업이 있다면 몇 가지 대안을 연구해야 한다

꼭 웹페이지에서 해야 하는 작업인가: 만약 개발자의 최신 개발 기기에서도 오랜 시간이 소요되는 작업이라면 실제 사용자가 이용하는 경우에는 더욱 오래 걸릴 것이다 일반적인 사용자들의 기기는 그다지 성능이 좋지 못하고 또 기기의 환경이 쾌적하지도 않다 
꼭 웹페이지에서 처리해야 하는 작업이 아니라면 서버로 옮겨서 처리하는 것이 좋다

긴 작업을 여러 개로 분리하기: 단순히 실행이 오래 걸릴 것 같은 작업을 분리하는 것뿐만 아니라 웹페이지 최초 로딩에 필요하지 않은 내용을 나중에 불러오는것도 포함된다 예를 들어 웹페이지에서 팝업이나 레이어의 경우 사용자의 액션으로 인해 노출되는 이러한 요소들은 당장의 로딩에 필요하지 않은 리소시다 이러한 리소스는 리액트의 Suspense와 lazy를 혹은 Next.js의 dynamic을 이용해 나중에 불러오게 할 수 있다

자바스크립트 코드 최소화
번들링 도구를 이용하여 필요없는 코드를 제거한다고 해도 여전히 웹페이지를 불러오는 데 사용되지 않은 필요 없는 코드가 존재할 수 있다
이러한 코드를 크롬 개발자 도구를 통해 확인할 수 있다
확인하고 싶은 사이트를 방문한 다음 크롬 개발자 도구로 들어가 커버리지를 클릭한다
그 다음 기록 버튼을 클릭하고 웹페이지를 새로고침하자

표시된 모든 코드들이 필요 없는 코드이므로 삭제해야 한다는 것은 아니다 이 중에는 사용자의 특정 이벤트에 따라 실행되는 코드, 예기치 못한 상황에서 실행될 코드 등 다양한 것들이 존재할 수 있다
이러한 코드들은 당장에 급하지 않은 코드로 간주해 지연 로딩 기법, 사용자가 불러오거나 우선순위를 낮춰서 불러오는 것이 좋다

또한 폴리필의 크기가 제법 크므로 실제 코드에서 사용하는 기준이 아닌 인터넷 익스플로러 11에 없는 코드를 기준으로 하게 되면 폴리필의 크기가 기하급수적으로 커진다

폴리필을 넣기 전에 두 가지를 고려해야 한다
1. 폴리필이 필요한 환경인가
2. 꼭 필요한 폴리필인가
만약 사용하는 곳이 몇 군데 되지 않는다면 폴리필보다 직접 저수준 자바스크립트 코드를 작성해 구현하는 편이 코드 크기를 줄이는 데 도움이 될 수 있다


타사 자바스크립트 코드 실행의 지연
제 3자가 만든 타사 자바스크립트를 넣은 경우 이로 인해 메인 스레드가 잠시 점유되고 사용자에게 안 좋은 반응성을 제공한다면 주객이 전도되는 상황에 마딱뜨릴것이다

이러한 타사 스크립트는 대부분 웹페이지 로드에 중요한 자원이 아니므로 <script>의 async와 defer를 이용해 지연 불러오기를 하는 것이 좋다 

defer: script에 defer 속성이 있다면 먼저 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드 다운로드 중에도 HTML 파싱 등의 메인 스레드 작업은 멈추지 않는다 다운로드가 완료됐다 하더라도 이 스크립트의 실행은 페이지가 완전히 로딩된 이후에 맨 마지막에 실행

async: script에 async 속성이 있다면 마찬가지로 병렬로 다운로드 async 리소스의 다운로드가 완료되어 버리면 다른 리소스의 다운로드를 기다리지 않고 바로 실행 

둘 다 없는 경우: script를 만나는 순간 다운로드가 우선되며 다운로드가 완료되면 코드 실행이 우선된다 다른 작업은 다운로드와 실행이 끝날 때까지 미뤄진다

만약 광고와 같이 실제 사용자의 뷰포트 위치에 따라 불러와야 하는 컴포넌트라면 Intersection Observer를 이용해 뷰표트에 들어오는 시점에 불러오는 것이 좋다 광고는 물론 개발자와 웹페이지 제공자에게 중요한 리소스이지만 어디까지나 사용자가 좋은 웹사이트 경험을 얻고 페이지에 머물러야만 유의미한 리소스라고 봐야 한다 따라서 사용자가 기대하지 않은 추가적인 리소스는 실행을 조금 뒤로 미뤄두고 실행하는 시점을 최적화하는 것이 좋다


누적 레이아웃 이동(CLS)
웹사이트에서 로딩이 끝난 줄 알고 무언가를 클릭하려고 했는데 그 사이에 다른 요소가 로딩되면서 원래 클릭하려고 했던 요소를 클릭하지 못하거나
혹은 내가 읽고 있던 문가가 다른 요소의 출력으로 사라지는 등 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것이 누적 레이아웃 이동(CSL: Cumulative Layout Shift)이라고 한다

리액트의 경우 useEffect가 많을수록 클라이언트에서 처리해야 하는 작업이 많아진다
function Banner() {
    const [show, setShow] = useState(false)

    useEffect(() => {
        ;(async function() {
            const result = await fetchBannerInfo()

            if(result.ok){
                setShow(true)
            }
        })()
    }, [])

    if (!show){
        return null
    }

    return <BannerHeader>초특가 이벤트 진행 중!</BannerHeader>
}

해당 예제는 useEffect 내부에서 배너 관련 정보를 비동기로 요청한 다음 원하는 응답이 오면 배너를 띄우는 컴포넌트
사용자는 렌더링이 완료된 이후부터 API의 응답을 받아 다시 배너가 노출되면 레이아웃이 변경된다 즉 사용자가 보고 있던 콘텐츠의 위치가 배너로 인해 밀리거나 상호작용하려고 했던 요소의 위치가 바뀌면서 상호작용에 실패하게 된다

최초 렌더링 이후에 실행되는 useEffect가 많을수록 그리고 이 useEffect가 렌더링에 영향을 미칠수록 이 누적 레이아웃 이동에 좋지 못한 점수를 받을 가능성이 커진다

누적 레이아웃 이동은 사용자의 가시적인 콘텐츠에 영향을 미쳐야 하기 때문에 뷰포트 내부의 요소에 대해서만 측정하며 뷰포트 밖의 요소에 대해서는 측정하지 않는다

요소가 추가됐다 하더라도 다른 요소의 시작 위치에 영향을 미치지 않는다면 레이아웃 이동으로 간주되지 않는다
사용자 액션으로 인해 발생한 레이아웃 이동은 점수에 포함되지 않는다

점수 계산 시 포함되는 내용
영향분율: 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율을 의미 예를 들어 레이아웃 이동이 발생한 요소의 높이가 10이고 예기치 않은 레이아웃 이동으로 인해 10만큼 내려갔다고 가정 시 이 경우 뷰포트의 높이가 100이라고 가정한다면 레이아웃 이동으로 인해 총 10 + 10 만큼 뷰포트에 영향을 미쳤으므로 이 경우 영향분율은 0.2점이 된다 ((10 + 10) / 100 = 0.2)

거리분율: 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지를 의미 예를 들어 예기치 않은 레이아웃 이동으로 인해 10만큼 내려갔고 전체 뷰포트가 100이라면 0.1점이 된다(10/100)

이 두 가지 점수를 곱해서 최종 점수를 계산 이 경우 최종 점수는 0.02점이 된다(0.2 * 0.1)

기준 점수
누적 레이아웃 이동의 경우 0.1 이하인 경우 좋은, 0.25 이하인 경우 보통이며 그 외에는 개선이 필요한 나쁜 점술 ㅗ보고


개선 방안
삽입이 예상되는 요소를 위한 추가적인 공간 확보
useEffect 내부에서 요소에 영향을 미치는 작업, 특히 뷰포트 내부에서 노출될 확률이 높은 작업을 최소화하는 것이 좋다
useEffect 사용이 불가피하다면 useLayoutEffect훅을 사용해 보는 것 또한 검토해 볼 만 하지만 이는 동기적으로 발생해 브라우저의 페인팅 작업에 영향을 미치기 떄문에 로딩이 오래 걸리는 것과 같이 보일 수 있다 이는 누적 레이아웃 이동을 막으려다가 다른 모든 작업에 악영향을 끼칠 수 있으므로 신중하게 선택해야 한다

스켈레톤 UI처럼 무언가가 동적으로 뜰 것으로 예상되는 공간을 미리 확보해 두는 것도 좋은 방법이다. 레이아웃 이동을 막으면서 클라이언트 시점에 정해지는 콘텐츠를 안정적으로 보여줄 수 있으므로 대부분의 경우에 추천할 만한 방법이다 그러나 이 역시도 해당 영역이 뜨지 않는 케이스가 있다면 누적 레이아웃 이동을 피하기 어렵다

가장 좋은 방법은 서버 사이드 렌더링이다 서버에서 이러한 동적인 요소의 유무를 사전에 판단해 클라이언트에 HTML을 미리 제공해 준다면 깔끔하게 처리할 수 있지만 타사 스크립트에 의존해 처리하는 경우 서버 사이드 렌더링이 불가능할 수도 있으므로 이러한 경우 앞에 언급한 벙법들을 사용해야 한다

폰트 로딩 최적화
폰트 또한 레이아웃 이동을 일으키는 원인 중 하나다
폰트로 인해 발생할 수 있는 문제는 크게 두 가지다
FOUT(flash of unstyled text): HTML 문서에서 지정한 폰트가 보이지 않고 대체 기본 폰트로 보이고 있다가 뒤늦게 폰트가 적용되는 현상

FOIT(flash of invisible text): HTML 문서에서 지정한 폰트가 보이지 않고 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상

폰트는 각각 고유의 높이와 너비를 가지고 있다 즉 미처 지정한 폰트가 다운로드되기 전에 텍스트를 노출하려고 한다면 높이와 크기가 다른 기본 폰트를 기반으로 한 텍스트를 노출해서 혹은 미처 텍스트를 노출하지 못해서 누적 레이아웃 이동이 발생할 수 있다

따라서 사용자 기본 폰트 이외에 다른 폰트로 웹페이지를 보여주고 싶다면 다음과 같은 점을 유념해야 한다

<link>의 preload 사용: <link> 요소의 rel=preload는 페이지에서 즉시 필요로 하는 리소스를 명시하는 기능 preload로 지정된 요소는 웹페이지의 생명주기에서 초기에 불러와야 하는 중요한 리로스로 간주되므로 브라우저는 리소스를 더 빠르게 사용할 수 있도록 준비해 준다 따라서 rel=preload로 스타일이나 폰트를 지정하면 페이지의 렌더링을 가로막거나 레이아웃을 방해할 가능성이 줄어든다

font-family: optional: 폰트를 불러올 수 있는 방법은 크게 다섯 가지로 나뉜다

auto(기본값): 브라우저가 폰트를 불러오는 방법을 결정
block: 폰트가 로딩되기 전까지 렌더링을 중단(최대 3초) 웹 폰트의 로딩이 완료되면 비로소 폰트를 적용
swap: 앞서 언급한 FOUT방식 
fallback: 이 옵션을 사용하면 100ms간 텍스트가 보이지 않고 그 이후에 폴백 폰트로 렌더링 그리고 3초 안에 폰트가 로딩된다면 해당 웹 폰트로 전환하고 그렇지 않다면 폴백 폰트를 계속 사용
optional: 100ms간 텍스트가 보이지 않고 폴백 폰트로 렌더링한다 그러나 0.1초 이내로 폰트가 다운로드돼 있거나 캐시돼 있지 않다면 폴백 폰트 사용
브라우저가 네트워크 상태를 파악해 일정 기간 폰트를 다운로드하지 못한다면 연결 취소


적절한 이미지 크기 설정
img{
    width: 100%;
    height: auto
}
너비는 기기의 너비대로 높이는 그 그림이 너비를 가지면 자동으로 비례해서(auto) 설정
이 경우 누적 레이아웃 이동이 커지는 결과를 낳는다 높이를 이미지가 완전히 다운로드되기 전까지는 알 수 없기 때문에 이미지의 높이를 높게 잡아 뒀다가 이미지가 완전히 로딩 완료된 이후에 기기의 너비만큼 높이를 계산해서 마침내 이미지 크기만큼 자리 잡을 수 있게 된다 heigth:auto 기법은 반응형 웹사이트에 최적화할 수 있는 기법으로 기기의 너비가 어떻게 되든 원본 이미지의 가로세로 비율이 일정해 사용자에게 최적의 이미지를 보여줄 수 있다는 장점이 있다 그러나 앞선 사례처럼 이미지의 높이를 명확하게 알지 못하기 때문에 레이아웃 이동이 크게 발생한다는 단점이 있다

이를 해결하는 방법
width, height 지정: 지정하면 브라우저가 이미지를 로딩하기 전에 적절한 가로세로 비율을 계산해 이미지가 표시되는 만큼 면적을 할당해 둔다 이는 aspect-ratio속성 덕분인데 이 속성은 부라우저의 유저 에이전트 스타일시트(브라우저가 기본으로 제공하는 스타일)에 포함돼 있으며 이지미의 가로세로 비율을 자동으로 맞춰주는 역할을 한다 이를 통해 예기치 못하게 이미지 롣ㅇ으로 인해 레이아웃이 이동하는 것을 막을 수 있다 그러나 이 aspect-ratio를 지원하지 않는 오래된 브라우저나 CSS로딩 실패 등의 시나리오를 고려한다면 이렇게 축약된 비율보다 실제 원하는 이미지 크기에 맞는 비율을 적어두는 것이 좋다

만약 사용자 뷰포트 너비에 맞춰 다른 이미지를 제공하고 있는 경우 즉 반응형 이미지를 사용하고 싶다면 srcset속성을 사용
가로세로 크기가 다른 여거 개의 이미지를 미리 준비해 둔 다음 브라우저가 상황에 맞게 이미지를 사용할 수 있도록 준비하면 된다
반드시 ,로 구분돼 있어야 하며 너비를 알려주는 w를 사용해야 한다
<img
    width="1000"
    height="1000"
    src="image-1000.jpg"
    srcset="image-1000.jpg 1000w, image-2000.jpg 2000w, image-3000.jpg 3000w"
    alt="이미지"
/>


그 외에 중요한 지표
최초 바이트까지의 시간(Time To First Byte, TTFB)
브라우저가 웹페이지의 첫 번째 바이트를 수신하는데 걸리는 시간을 의미 즉 페이지를 요청했을 때 요청이 완전히 완료되는 데 걸리는 시간을 측정하는 것이 아니라 최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정하는 지표 이 지표는 600ms 이상 걸릴 경우 개선이 필요한 것으로 간주

이는 특히 서버 사이드 렌더링을 하고 있는 애플리케이션에서 주의 깊게 봐야 할 지표
서버 사이드 렌더링은 최초 페이지를 만들기 위해 서버에서 어느 정도 작업을 수행해야 하기 때문이다 서버에서 HTML을 만들기 위해 해야 하는 작업이 많거나 느릴수록 최초 바이트까지의 시간이 길어지게 된다
이는 사용자가 페이지 요청 시 빈 화면이 뜨는 것을 의미하며 사용자 경험을 저해한다

최초 바이트까지의 시간 개선시 고려사항
서버 사이드 렌더링을 수행하고 있다면
로직을 최적화해 페이지를 최대한 빨리 준비시켜야 한다 예를 들어 getSErverSideProps 함수의 실행과 그 결과에 따른 정적 페이지 렌더링 같은 작업이다
서버 사이드 렌더링 시에 API 호출이 필요하다면 이 API 호출 또한 최적화할 필요가 있다 호출 횟수와 가져오는 정보의 크기를 최소화해서 최대한 API 응답의 속도를 빠르게 하고 크기를 가능한 한 줄여야 한다

웹페이지의 주된 방문객의 국적을 파악해 최대한 해당 국적과 가깝게 서버를 위치시키는 것이 좋다 응답해야 할 서버가 사용자와 가까울수록 응답 속도가 빨라지기 때문이다

리액트 서버 사이드 렌더링이라면 renderToNodeStream, renderToStaticNodeStream과 같은 스트리밍 API를 사용한는 것이 좋다 renderToString()은 완전히 HTML을 그리고 나서야 다운로드가 완료되지만 스트리밍을 사용할 경우 완성된 영역부터 조각조각 받을 수 있어 최초 바이트까지의 시간을 단축할 수 있다



최초 콘텐츠풀 페인트(First Contentful Paint, FCP)
최초 콘텐츠풀 페인트(First Contentful Paint, FCP)란 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간을 측정한다 웹사이트에 접속한 순간부터 페이지에 뭐라도 뜨기 시작한 시점까지의 시간을 의미 

최초 콘텐츠풀 페인트는 1.8초 이내에 이뤄진다면 좋음 3.0초 이내에 보통 그 이후는 개선이 필요한 것으로 보고된다 

최초 콘텐츠풀 페인트를 개선하려면 다음 사항을 고려해야 한다

최초 바이트까지의 시간(TTFB)을 개선: 일단 뭐라도 다운로드가 시작돼야 렌더링 할 수 있다. 렌더링을 최대한 빠르게 하기 위해 최초 바이트까지의 시간을 
단축해야 한다

렌더링을 가로막는 리소스 최소화: 자바스크립트나 CSS 같은 렌더링을 가로막는 리소스를 최소화하고 렌더링을 방해하는 리소스를 비동기적으로 로드하도록 해야 한다 렌더링이 최대한 빨리 이뤄져야 사용자에게 뭐라도 보여줄 수 있다

Above the Fold에 대한 최적화: Above the fold란 신문에서 비롯된 용어로 신문이 독자에게 제공됐을 때 가장 먼저 보이는 영역을 일컫는 말이다 일반적으로 신문은 1페이지가 반으로 접혀서 보ㅕ지는 형태인데 이 반으로 접혀져서 보이는 영역을 Above the fold라 한다 이와 비슷하게 웹에서는 최초에 스크롤을 굳이 하지 않아도 보이는 영역을 Above the fold라고 한다 이 영역은 최대한 사용자에게 빠르게 무언가를 보여줘야 하는 영역이므로 게으른 로딩을 하거나 스크립트(앞서 언급한 리액트의 useEffect와 같이)에 의존해 요소가 렌더링되는 것을 피해야 한다 게으른 로딩이나 스크립트에 의존하는 것은 모두 최초 콘텐츠풀 페인트에 도움이 되지 않는다

페이지 리다이렉트 최소화: 만약 특정 페이지에서 다른 페이지로 리다이렉트를 해야 한다면 그만큼 사용자에게 무언가 보여줄 수 있는 시간이 지연되기 마련이다 리다리엑트는 없거나 최소한으로 유지해야 한다

DOM 크기 최소화: HTML의 크기가 크다면 즉 DOM이 복잡하고 크다면 그만큼 렌더링되는 데 시간이 오래 걸린다 구글의 기준에 따르면 전체 DOM 노드는 1500개 미만으로 깊이는 32단계 정도까지만 그리고 부모 노드는 자식 노드를 60개 정도만 가지고 있어야 한다 이 이상으로 DOM이 크고 복잡해지면 브라우저가 이를 파악해 렌더링하는 데 시간이 오래 걸리게 된다 만약 웹페이지를 소스 보기로 확인해 봤을 때 DOM이 필요 이상으로 많고 복잡하다면 이를 줄일 수 있는 방법을 고민해 봐야 한다

