웹사이트 성능과 사용자 경험 사이의 상관관계
2019년 미국 시애틀에 있는 디지털 마케팅 에이전시 회사인 Protent의 조사

- 웹사이트의 성능이 끼치는 영향
1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 전자상거래 전환율(실제 구매로 이어지는 고객의 비율)이 2.5배 더 높다

0 ~ 5초 범위에서 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다 즉 5초 이상 느려지면 전환율은 20% 가까이 떨어진다

페이지 로드 시간이 0 ~ 2초 사이인 페이지에서 가장 높은 전환율을 달성할 수 있다

소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는 데 영향을 미친다고 밝혔다

절반 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요 없다고 밝혔다

- 구글에서 내놓은 사이트 성능에 관한 통계
전체 웹피이지를 표시하는 데 필요한 최적의 평균 리소스 요청 수는 50회 미만이다(한 페이지를 로딩하는 데 50회 미만의 요청이 발생해야 한다)

평균적으로 웹 페이지 전체를 요청하는 데 15.3초가 걸린다

인간의 뇌와 신경계를 분석한 결과 페이지 로드 시간이 1초에서 10초로 늘어날수록 모바일 사이트를 이탈할 확률이 123% 증가한다

또한 구글은 요즘의 웹사이트의 성능에 대해 다음과 같은 글을 남겼다

전 세계의 사용자의 대부분이 모바일을 3G가 아닌 4G로 사용하고 있음에도 불구하고 대부분의 모바일 사이트는 여전히 느리고 너무 많은 요소 때문에 비대해졌다


개발자들이 성능에 크게 관심을 기울이지 않는 것 또한 사실이다

이유로는

1. 개발자의 기기는 대부분 일반적인 사용자의 평균적인 기기보다 성능이 뛰어나기 때문에 이러한 문제를 대체로 느끼지 못한다
또한 네트워크 환경도 안정적이다 따라서 웬만큼 잘못되지 않은 이상 개발자의 기기에서 성능 문제를 경험하기란 어렵다

2. 성능 개선 작업은 새로운 기능을 개발하는것보다 쉽지도, 재밌지도 않고 서비스를 개발하는 작업 대비 눈에 띄는 성능 향상을 기대하기도 어렵다는 점이다
실무 개발자들은 항상 많은 양의 업무 요청을 처리하고 버그와 씨름하고 있기 때문에 대부분의 서비스 출시를 최우선 과제로 삼는다



핵심 웹 지표
외국에서는 Core Web Vital로 알려져 있다 핵심 웹 지표는 구글에서 만든 지표로 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일겉는 용어

구글에서 핵심 웹 지표로 꼽는 지표는 다음과 같다

최대 콘텐츠풀 페인드(LCP: Largest Contentful Paint)
최초 입력 지연(FID: First Input Delay)
누적 레이아웃 이동(CSL: Cumilative Layout Shift)

핵심 지표까지는 아니지만 특정 문제를 진단하는데 사용될 수도 있는 요소
최초 바이트까지의 시간(TTFB: Time To First Byte)
최초 콘텐츠풀 시간(FCP: First Contentful Paint)


최대 콘텐츠풀 페인트(LCP)
페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간
뷰포트는 사용자에게 현재 노출되는 화면을 의미 사용자에게 노출되는 영역은 기기에 의존하므로 뷰포트 크기는 기기마다 다르다

뷰포트 내부에서 큰 이미지와 텍스트는 다음과 같이 정의
<img>
<svg>내부의 <image>
poster 속성을 사용하는 <video>
url()을 통해 불러온 배경 이미지가 있는 요소
텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
이 블록 레벨 요소에는 <p>, <div>등이 포함

요약하자면 각 엘리먼트가 등장한 시점부터 텍스트 또는 이미지가 완전히 로딩되는 시점

실제 크기가 크더라도 뷰포트 영역 밖에 넘치는 요소가 있다면 해당 영역의 크기는 고려되지 않는다
따라서 아무리 콘텐츠 높이가 길어도 최대 콘텐츠풀 페인트에 영향을 미치는 부분은 오직 뷰포트 영역뿐이다

사용자가 페이지가 어느 정도 로딩됐다고 인지하는 시점
ex) document가 1000~2000줄에 달하는 웹사이트의 경우 하단 영역은 IntersectionObserver로 구현돼 있어 아직 뷰포트에 걸치지 않아 미처 로딩돼 있지
않다고 하더라도 일단 사용자에게 노출되는 부분만 로딩돼 있다면 사용자는 페이지 로딩이 완료됐다고 느낄것이다
즉 뷰포트 영역을 기준으로 판단할 것이다

최대 콘텐츠풀 페인트에서 좋은 점수란 해당 지표가 2.5초 내로 응답이 오는 것이다 4초 이내로 응답이 온다면 보통, 그 이상이 걸리면 나쁨으로 판단

개선 방안
텍스트는 언제나 옳다
최대 콘텐츠풀 페인트 예상 영역에 이미지가 아닌 문자열을 넣는 것

이미지는 어떻게 불러올 것인가?
개발자가 선택할 수 있는 이미지 노출 방법
1. img
<img src="lcp.jpg" ... />
2. svg
<svg xmlns="http://www.w3.org/1000/svg">
    <image href="lcp.jpg>
</svg>
3. 비디오의 경우
<video poster="lcp.jpg"></video>
4. background-img: url()
<div style="background-image: url(lcp.jpg)">...</div>

1번과 3번의 예제가 빠르게 완성된다
<img>: 이미지는 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 빠르게 요청이 일어난다 프리로드 스캐너란 HTML을 파싱하는 단계를 차단하지 않고 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 찾아 로딩하는 브라우저의 기능이다 <img> 내부의 리소스는 이처럼 HTML 파싱이 미처 완료되지 않더라도 프리로드 스태너가 병렬적으로 리소스를 다운로드하므로 최대 콘턴츠풀 페인트 요소를 불러오기에 적절한 방법이다 이는 <picture>도 마찬가지다

<svg>: <svg> 내부의 <img>가 로딩이 완료되기 전까지는 최대 콘텐츠풀 페인트가 완료되지 않는다 <svg>는 모든 리소스를 다 불러온 이후에 이미지를 불러온다

<video>의 poster: poster는 사용자가 video요소를 재생하거나 탐색하기 전까지 노출되는 요소 이 역시 마찬가지로 프리로드 스캐너에 의해 조기 발견되어 
<img>와 같은 성능을 나타낸다 poster가 없는 video의 경우 video를 실제로 로딩해 첫 번째 프레임을 해당 poster 리소스로 대체할 예정이다 그러므로 video가 최대 콘텐츠풀 페인트에 영향을 받을 것 같다면 poster를 반드시 넣어주는 것이 좋다

background-image: url(): background-image를 비롯해서 CSS에 있는 리소스는 항상 느리다 이러한 리소스는 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문 

그 밖에 주의점
이미지 무손실 압축: 웹 서비스 이미지는 가능한 한 무손실 형식으로 압축해 최소한의 용량으로 서비스하는 것이 좋다

loading=lazy 주의: loading=lazy는 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략으로 <img>, <iframe>등에 적용할 수 있지만 문제는 최대 콘텐츠풀 콘텐츠의 이미지는 중요하지 않은 리소스로 분류해서는 안된다 이는 그저 로딩 속도만 늦출 뿐 지표 점수에는 도움이 되지 않는다

fadein과 같은 각종 애니메이션: 당연하게도 이미지가 그냥 뜨는 것보다 fadeIn ease 10s와 같이 처리한다면 최대 콘텐츠풀 페인트도 그만큼 늦어진다

클라이언트에서 빌드하지 말 것: 서버에서 빌드해온 HTML을 프리로드 스캐너가 바로 읽어서 최대 콘텐츠풀 페인트로 빠르게 가져간다
만약 최대 콘텐츠풀 페인트에 대해 다음과 같은 useEffect 코드가 있다면
useEffect(() => {
    ;(async function loadData() {
        const result = await fetch('https://example.com/data)

        if(result.ok){
            setShow(true) //최대 콘텐츠풀 페인트 영역 노출
        }
    })()
}, [])
이 코드는 HTML을 다운로드한 직후가 아닌 리액트 코드를 파싱하고 읽어서 API 요청을 보내고 응답을 받는 만큼 늦어진다 따라서 가능한 한 이 영역은 서버에서 미리 빌드된 채로 오는 것이 좋다

최대 콘텐츠풀 리소스는 직접 호스팅: 가능하다면 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋다 일반적인 경우 Cloudinary같은 이미지 최적화 서비스를 사용해 하나의 이미지에 대해 크기도 줄이고 포맷도 변환하고 압축해서 이미지를 관리하지만 다른 출처(origin)에서 이렇게 정제한
이미지를 가져오는 것은 최적화에 별로 좋은 영향을 미치지 않는다 왜냐하면 이미 연결이 맺어진 현재 출처와는 다르게 완선히 새로운 출처의 경우에는 네트워크 커넥션부터 다시 수행해야 하기 때문이다
때문에 중요한 리소스는 직접 다루고 그 외에 덜 중요한 리소스에 대해서만 이미지 최적화 서비스를 사용하는 식으로 관리하는 것이 좋다