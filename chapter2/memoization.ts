{
    // useMemo, useCallback 혹은 고차 컴포넌트인 memo는 리액트 렌더링을 최소한으로 줄이기 위해 제공   
}

{
    // 메모이제이션
    // 무조건 메모이제이션이 필요하다와 섣불리 해서는 안된다가 명확히 정해지지 않음

    // 꼭 필요한 곳에만 메모이제이션을 추가하자는 주장
    // 메모이제이션도 어디까지나 비용이 드는 작업이므로 최적화에 대한 비용을 지불 할 때는 항상 신중해야 한다

    function sum(a, b){
        return a + b
    }

    // 위 예제는 극단적이긴 하지만 대부분의 가벼운 작업 자체는 메모이제이션해서 자바스크립트 메모리 어딘가에 두었다가
    // 다시 꺼내오는 것보다는 매번 이 작업을 수행해 결과를 반환하는것이 빠를 수도 있다
    
    // 리액트의 입장에서는 메모이제이션은 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
    // 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두 가지 비용이 있다
    // 항상 메모이제이션은 신중하게 접근해야 하며 섣부른 최적화는 항상 경계해야한다
    // 만약 이러한 비교와 렌더링이 문제가 됐다면 리액트에서는 진작에 모든 컴포넌트를 PureComponent로 만들거나 memo로 감쌌을 것이다
    // 이전 결과를 캐시로 저장해 미래에 더 나은 성능을 위해 메모리를 차례로 점유하여 자원을 사용한다
    // 메모이제이션으로 인한 성능 개선이 렌더링보다 낫지 않다면 결국 하느니만 못하는 상황을 마주하게 된다
}

{
    // 렌더링 과정의 비용은 비싸다 모조리 메모이제이션 하자
    // 섣부른 최적화인지 여부와는 관계 없이 만약 해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함돼 있고
    // 심지어 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 memo나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을 때가 분명히 있다
    // 여기서 
    // memo를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용
    // memo를 일단 그냥 다 적용 
    // 두 가지 방법을 택할 수 있다 첫 번째 주장이 가장 이상적이지만 애플리케이션 규모가 커지고 개발자가 많아지며 복잡성이 증가하는 상황에서도
    // 최적화나 성능 향상에 쏟을 시간이 많지 않다
    // 잘못된 memo로 지불해야 하는 비용은 props에 대한 얕은 비교이다
    // 메모이제이션을 위해서는 cpu와 메모리를 사용해 이전 렌더링 결과물을 저장하고 리렌더링이 필요 없다면 이전 결과물을 사용한다
    // 또한 리액트도 재조정 알고리즘을 위해 이전 결과물은 어떻게든 저장해두고 있다
    // 따라서 우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교 뿐이다 물론 props가 크고 복잡하면 해당 비용 또한 커진다
    // 반면 memo를 하지 않았을 때 발생할 수 있는 문제는 다음과 같다
    // 렌더링 비용
    // 컴포넌트 내부의 복잡한 로직 재실행
    // 위 두 가지 모두 자식 컴포넌트에서 반복
    // 리액트가 구 트리와 신규 트리 비교
    // mome를 하지 않았을 때 치러야 할 잠재적인 위험 비용이 더 크다

    // useMemo와 useCallback을 사용해 의존성 배열을 비교하고 필요에 따라 값을 재계산하는 과정과 이러한 처리 없이 값과 함수를 매번 재생성하는
    // 비용 중에서 무엇이 더 저렴한지 매번 계산해야 한다
    // 이 또한 마찬가지로 무조건 메모이제이션하는 방법을 먼저 고민할 필요가 있다
    // 리렌더링 발생 시 메모이제이션과 같은 별도 조치가 없다면 모든 객체가 재생성되고 참조가 달라진다
    // 달라진 참조에 대한 값을 어디서든 쓰지 않는다면 큰 문제가 되지 않을 수 있지만 이 값이 useEffect와 같은 의존성 배열에 쓰이면 
    // 변경된 참조로 인해 다른 쪽에도 영향을 미친다

    // 예제
    function useMath(number: number){
        const [double, setDouble] = useState(0)
        const [triple, setTriple] = useState(0)

        useEffect(() => {
            setDouble(number * 2)
            setTriple(number * 3)
        }, [number])

        return {double, triple}
    }

    // useMath는 인수로 10이라는 고정값을 넘겨주므로 value는 항상 같다
    // 그렇기 때문에 useEffect로 감싼 console.log가 실행이 안될것 같지만 버튼을 클릭하여 
    // 렌더링을 일으키면 console.log가 출력된다
    // 함수 컴포넌트인 App이 호출되면서 useMath가 계속해서 호출되고 객체 내부의 값은 같지만 참조가 변경되기 떄문
    // useMath의 반환값을 useMemo로 감싼다면 값이 변경되지 않는 한 같은 결과물을 가질 수 있고 
    // 사용하는 쪽에서도 참조의 투명성을 유지할 수 있게 된다
    export default function App(){
        const [counter, setCounter] = useState(0)
        const value = useMath(10)

        useEffect(() => {
            console.log(value.double, value.triple)
        }, [value])

        function handleClick(){
            setCounter((prev) => prev + 1)
        }

        return (
            <>
                <h1>{counter}</h1>
                <button onClick={handleClick}>+</button>
            </>
        )
    }

    // 최적화에 대한 확신이 없다면 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 하는것이 좋다
}

{
    // 리액트를 배우고 있거나 깊이 이해하고 싶고 이를 위한 시간적 여유가 있다면 섣부른 메모이제이션을 지양하는 자세를 견지하면서 
    // 실제 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보는 식으로 메모이제이션을 적용하는 것을 권장
    // 만약 현업에서 리액트를 사용하고 있거나 실제로 다룰 예정이지만 성능에 대해 깊게 연구해 볼 시간적 여유가 없는 상황이라면 
    // 일단 의심스러운 곳에는 먼저 다 적용해 볼 것을 권장한다
    // props에 대한 얕은 비교를 수행하는 것보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비싸다
    // useMemo와 useCallback 또한 마찬가지
    // useCallback의 경우 대부분 다른 컴포넌트의 props로 넘어가는 경우가 많을 것이다 
    // 이 props로 넘어갔을 때 참조 투명성을 유지하기 위해서는 useCallback을 사용하는것이 좋다 (useMemo 또한 마찬가지)
    // 성능에 대해서 지속적으로 모니터링하고 관찰하는 것보다 섣부른 메모이제이션 최적화가 주는 이점이 더 클 수 있다
}